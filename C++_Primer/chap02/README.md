# 第二章 变量和基本类型
数据类型是程序的基础，告诉我们能在数据上执行的操作，以及数据的意义。C++ 支持广泛的数据类型，包括内置类型、标准库定义的复杂数据类型，以及用户自定义类型。

## 2.1 基本内置类型
内置基本类型包括：

* 算术类型：
    * 整型： short, int, long, long long, bool, char...
    * 浮点型：float, double, long double
* 空类型：不对应具体的值，用于特定场合，比如函数不返回任何值时用`空类型` void *作为返回类型。

除了bool型和扩展的字符型外，其他整型可以划分为：带符号类型和无符号类型。

### 2.1.2 类型转换
*[type_conversions.cpp](type_conversions.cpp)*

对象的类型定义了对象包含的数据范围和能参与的运算，当我们使用了一种类型而其实对象应该取另一类型时，程序会执行`自动类型转换`（当然不是所有的场合都能进行类型转换）。

当一个算术表达式中既含有无符号数又有int值时，会将计算结果将转换为无符号类型。

> 切勿混用带符号数和无符号数。

### 2.1.3 字面值常量
*[literal](literal)*

有些变量，比如10被称作字面值常量，因为他们的值不言而喻。每一个字面值常量的值和形式决定了它的数据类型，不过我们也可以通过添加前缀和后缀，改变一些字面值常量的默认类型。字面值常量可以分为如下几种：

* 整型和浮点型字面值：123, 123.0等十进制或者是八进制、十六进制；
* 字符和字符串字面值：字符字面值'a', 或者字符串字面值"abcd"；
* 转义序列：不可打印字符或者是C++中有特殊含义的字符；
* 布尔字面值：true, false；
* 指针字面值：空指针`nullptr`(0和NULL也是，不过C++ 11 不推荐)；

## 2.2 变量
*[variable.cpp](variable.cpp)*

变量其实就是程序操作的`存储空间`的名字，每个变量都有一个数据类型，它决定了该变量所占内存空间的大小，布局方式，以及存放的值的范围。 

变量声明与变量定义：

* `变量定义`：类型说明符(type specifier)紧跟一个或者多个变量名组成的列表，最后以分号结束。定义时会为该变量申请存储空间，也可以同时给变量赋初始值。（**变量只能被定义一次**）
* `变量声明`：声明只是让程序知道某个变量的名字，变量声明规定了类型和名字，并且声明时不能初始化变量（试图初始化extern关键字标记的声明语句将引发错误）。

变量赋值与变量初始化：

* `赋值`：把变量当前值擦除，以一个新值来代替；
* `初始化`：定义变量时，赋予其初始值称为初始化，如果没有赋予初始值，可能会执行默认初始化（强烈建议，**初始化每一个内置类型的变量**）。此外，C++ 11全面支持`列表初始化`，列表初始化时初始值存在丢失信息的风险，编译不通过。

`标识符`（identifier）是我们程序中使用的名字，变量、函数、类等的名字都是标识符。标识符由数字、字母和下划线组成，其中必须以字母或者下划线开始，且大小写敏感。此外，一些名字供语言本身使用，如for, break, while等也不能用作标识符。

变量名命名规范：

1. 标识符要体现实际含义
2. 一般用小写字母
3. 自定义类型一般以大写字母开头
4. 如果标识符有多个单词组成，单词间应该有明显区分

`作用域（scope）`是程序的一部分，在其中名字有特别的含义，C++中大多数作用域以花括号分隔。

* 同一个名字在不同的作用域内可能指向不同的实体。
* 对于一个名字来说，其生存的作用域起始于名字的声明语句，以该语句所在的作用域尾部结束。
* 一个作用域一旦声明了语句，它所嵌套着的所有作用域都能访问改名字，也允许在内层作用域重新定义外层作用域已有的名字。

## 2.3 复合类型

*[compound_type.cpp](compound_type.cpp)*

复合类型是指基于其他类型定义的类型，这里介绍最常见的两种，`引用`和`指针`。

**引用**

为对象起了另一个名字，简单来说就是**引用即别名**。也就是说，**引用并非对象**，相反的，它只是为一个已经存在的对象所起的另一个不同的名字。

**指针**

指针是指向另外一种类型的复合类型，实现了对其他对象的间接访问。和引用不同的是，指针本身也是一个对象，允许对指针进行赋值和拷贝，在其生命周期内可以先后指向几个不同的对象。

指针存放的是某个对象的地址，要想获取该地址，可以使用`取地址符`（&既可以表示引用，也可以表示取地址，具体要看上下文）。如果指针指向了一个对象，可以使用`解引用符`来访问该对象内容。

指针的值应属于下列4种状态之一：

1. 指向一个对象
2. 指向对象所占空间的下一个位置，比如vec.end()
3. 空指针，没有指向任何对象
4. 无效指针，上述情况之外的其他值

对2、3、4类型的指针进行解引用操作，编译器可能不会报错，但是运行时将导致无法预料的后果（通常情况下程序会崩溃）。

> 使用未经初始化的指针是引发运行时错误的一大原因，因此好的编程习惯是初始化所有指针。

`void*` 是一种特殊类型的指针，可以存放任意对象的地址，一般用来作函数的输出输入。我们并不了解该地址中到底是什么类型的对象，因此无法访问内存空间中所存的对象，

### 2.3.3 更复杂的复合类型
*[compound_type\_more.cpp](compound_type_more.cpp)*

一个变量的定义包括一个基本数据类型(base type)和一组`声明符`(declarator)，同一条定义语句中，虽然基本数据类型只有一个，但声明符的形式却可以不同。*声明符是变量声明的组成部分，用来指定变量是否是函数、指针、引用或者数组。类型修饰符（比如\*, &）是声明符的一部分。*

涉及指针或者引用的声明，一般有两种写法（没有本质的区别）

1. 把修饰符和变量标识符写一起：**int *ptr**，这样可以强调变量的复合类型的特点（强烈推荐）；
2. 把修饰符和类型名写一起，**int* ptr**。

声明符中修饰符的个数并没有限制，当多个修饰符连接在一起时，按照逻辑关系（一般是**从内到外，从右到左**）进行解释即可。以指针为例，指针也是内存中的一个对象，因此可以把指针的地址再存放到另一个指针中去。

* 指向指针的指针：指针存放的是另一个指针的地址, **ptr; 
* 指向指针的引用：引用的对象是一个指针, *&ref;


## 2.4 const 限定符

## 2.5 处理类型

## 2.6 自定义数据结构



