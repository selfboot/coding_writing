# 第二章 变量和基本类型
数据类型是程序的基础，告诉我们能在数据上执行的操作，以及数据的意义。C++ 支持广泛的数据类型，包括内置类型、标准库定义的复杂数据类型，以及用户自定义类型。

## 2.1 基本内置类型
内置基本类型包括：

* 算术类型：
    * 整型： short, int, long, long long, bool, char...
    * 浮点型：float, double, long double
* 空类型：不对应具体的值，用于特定场合，比如函数不返回任何值时用`空类型` void *作为返回类型。

除了bool型和扩展的字符型外，其他整型可以划分为：带符号类型和无符号类型。

### 2.1.2 类型转换
*[type_conversions.cpp](type_conversions.cpp)*

对象的类型定义了对象包含的数据范围和能参与的运算，当我们使用了一种类型而其实对象应该取另一类型时，程序会执行`自动类型转换`（当然不是所有的场合都能进行类型转换）。

当一个算术表达式中既含有无符号数又有int值时，会将计算结果将转换为无符号类型。

> 切勿混用带符号数和无符号数。

### 2.1.3 字面值常量
*[literal](literal)*

有些变量，比如10被称作字面值常量，因为他们的值不言而喻。每一个字面值常量的值和形式决定了它的数据类型，不过我们也可以通过添加前缀和后缀，改变一些字面值常量的默认类型。字面值常量可以分为如下几种：

* 整型和浮点型字面值：123, 123.0等十进制或者是八进制、十六进制；
* 字符和字符串字面值：字符字面值'a', 或者字符串字面值"abcd"；
* 转义序列：不可打印字符或者是C++中有特殊含义的字符；
* 布尔字面值：true, false；
* 指针字面值：空指针`nullptr`(0和NULL也是，不过C++ 11 不推荐)；

## 2.2 变量
*[variable.cpp](variable.cpp)*

变量其实就是程序操作的`存储空间`的名字，每个变量都有一个数据类型，它决定了该变量所占内存空间的大小，布局方式，以及存放的值的范围。 

变量声明与变量定义：

* `变量定义`：类型说明符(type specifier)紧跟一个或者多个变量名组成的列表，最后以分号结束。定义时会为该变量申请存储空间，也可以同时给变量赋初始值。（**变量只能被定义一次**）
* `变量声明`：声明只是让程序知道某个变量的名字，变量声明规定了类型和名字，并且声明时不能初始化变量（试图初始化extern关键字标记的声明语句将引发错误）。

变量赋值与变量初始化：

* `赋值`：把变量当前值擦除，以一个新值来代替；
* `初始化`：定义变量时，赋予其初始值称为初始化，如果没有赋予初始值，可能会执行默认初始化（强烈建议，**初始化每一个内置类型的变量**）。此外，C++ 11全面支持`列表初始化`，列表初始化时初始值存在丢失信息的风险，编译不通过。

`标识符`（identifier）是我们程序中使用的名字，变量、函数、类等的名字都是标识符。标识符由数字、字母和下划线组成，其中必须以字母或者下划线开始，且大小写敏感。此外，一些名字供语言本身使用，如for, break, while等也不能用作标识符。

变量名命名规范：

1. 标识符要体现实际含义
2. 一般用小写字母
3. 自定义类型一般以大写字母开头
4. 如果标识符有多个单词组成，单词间应该有明显区分

`作用域（scope）`是程序的一部分，在其中名字有特别的含义，C++中大多数作用域以花括号分隔。

* 同一个名字在不同的作用域内可能指向不同的实体。
* 对于一个名字来说，其生存的作用域起始于名字的声明语句，以该语句所在的作用域尾部结束。
* 一个作用域一旦声明了语句，它所嵌套着的所有作用域都能访问改名字，也允许在内层作用域重新定义外层作用域已有的名字。

## 2.3 复合类型

*[compound_type.cpp](compound_type.cpp)*

复合类型是指基于其他类型定义的类型，这里介绍最常见的两种，`引用`和`指针`。

**引用**

为对象起了另一个名字，简单来说就是**引用即别名**。也就是说，**引用并非对象**，相反的，它只是为一个已经存在的对象所起的另一个不同的名字。

**指针**

指针是指向另外一种类型的复合类型，实现了对其他对象的间接访问。和引用不同的是，指针本身也是一个对象，允许对指针进行赋值和拷贝，在其生命周期内可以先后指向几个不同的对象。

指针存放的是某个对象的地址，要想获取该地址，可以使用`取地址符`（&既可以表示引用，也可以表示取地址，具体要看上下文）。如果指针指向了一个对象，可以使用`解引用符`来访问该对象内容。

指针的值应属于下列4种状态之一：

1. 指向一个对象
2. 指向对象所占空间的下一个位置，比如vec.end()
3. 空指针，没有指向任何对象
4. 无效指针，上述情况之外的其他值

对2、3、4类型的指针进行解引用操作，编译器可能不会报错，但是运行时将导致无法预料的后果（通常情况下程序会崩溃）。

> 使用未经初始化的指针是引发运行时错误的一大原因，因此好的编程习惯是初始化所有指针。

`void*` 是一种特殊类型的指针，可以存放任意对象的地址，一般用来作函数的输出输入。我们并不了解该地址中到底是什么类型的对象，因此无法访问内存空间中所存的对象，

### 2.3.3 更复杂的复合类型
*[compound_type\_more.cpp](compound_type_more.cpp)*

一个变量的定义包括一个基本数据类型(base type)和一组`声明符`(declarator)，同一条定义语句中，虽然基本数据类型只有一个，但声明符的形式却可以不同。*声明符是变量声明的组成部分，用来指定变量是否是函数、指针、引用或者数组。类型修饰符（比如\*, &）是声明符的一部分。*

涉及指针或者引用的声明，一般有两种写法（没有本质的区别）

1. 把修饰符和变量标识符写一起：**int *ptr**，这样可以强调变量的复合类型的特点（强烈推荐）；
2. 把修饰符和类型名写一起，**int* ptr**。

声明符中修饰符的个数并没有限制，当多个修饰符连接在一起时，按照逻辑关系（一般是**从内到外，从右到左**）进行解释即可。以指针为例，指针也是内存中的一个对象，因此可以把指针的地址再存放到另一个指针中去。

* 指向指针的指针：指针存放的是另一个指针的地址, **ptr; 
* 指向指针的引用：引用的对象是一个指针, *&ref;


## 2.4 const 限定符

*[const_basic.cpp](const_basic.cpp)*

const 限定符用来定义一个变量，使其值不能被改变。const对象一旦创建，其值就不能改变，因此必须初始化。对象的类型决定了其支持的操作，const类型的对象支持不改变其内容的操作（只读操作）。

默认情况下，const 对象仅在当前文件内有效，如果多个文件出现了同名的const 变量时，其实等同于在不同文件中分别定义了独立的变量。如果想在不同文件中共享const 变量，又不希望编译器为每个文件分别生成独立的变量，那么不管是声明还是定义都需要添加 `extern` 关键字。 （**书中说是声明、定义都需要加extern，但是程序中发现定义不需要加extern就行**）

### const 引用和指针
*[const_more.cpp](const_more.cpp)*

**对常量的引用**

可以将引用绑定到 const 对象上，称为对常量的引用（reference to const），对常量的引用不能修改所绑定的对象。

对常量的引用（经常简称为`常量引用`）其实只是对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量则没有做出要求。也就是说，允许一个常量引用绑定非常量的对象、字面值，甚至一个一般表达式。但是，对于一个常量对象来说，必须指定一个常量引用指向它，用一个非常量引用指向一个常量对象将引发错误。此外，必须用常量引用来绑定临时量（temporary）（所谓`临时量`对象，就是说编译器需要一个空间来暂存表达式的求解结果时临时创建的一个未命名的对象）。

**指向常量的指针**

指向常量的指针（pointer to const）不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针。和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。

> 这样理解指向常量的指针或者引用： 不过是指针或者引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。

**常量指针**

指针是对象，因此可以和其他对象类型一样，允许把指针本身定为常量，这样指针中保存的地址值不能改变。定义指针时，把 * 号放在const前面，说明该指针是一个`常量指针`。常量指针必须初始化。

用下面名词来区分 const 和指针的关系：

* `顶层 const`(top-level const)来表示指针本身是常量
* `底层const`(low-level const)表示所指的对象是一个常量。

我们也可以定义一个指针，既不可以改变其保存的地址值，也不能改变所指对象的值。

**constexpr 和 常量表达式**

`常量表达式`是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值是常量表达式，且用常量表达式初始化的 const 对象也是常量表达式。

C++ 11 新标准允许将变量声明为 `constexpr` 类型以便由编译器来验证变量的值是否是一个常量表达式。声明为 constexpr 的变量一定是一个常量，并且必须用常量表达式初始化。

如果 constexpr 中定义了一个指针，限定符仅仅对于指针有效，与指针所指的对象无关，也就是说是一个顶层指针。

## 2.5 处理类型

*[type_process.cpp](type_process.cpp)*

**类型别名**

类型别名（type alias）是一个名字，是某种类型的同义词。使用类型别名可以使复杂的类型名字变的简单明了、易于理解使用。由两种方法定义类型别名(建议使用第2种，更加清晰)

* typedef：`typedef type type_alias;`
* 别名声明：`using type_alias ＝ type;`（C++ 11）

**auto 类型说明符**

定义变量时需要清楚知道变量初始值的类型，但是有时候我们不知道表达式返回的类型。这时候可以用 auto 类型说明符让编译器去分析表达式所属的类型，然后再定义变量。（C++ 11）

编译器推断出来的auto类型和初始值的类型并不完全一样，它会聪明地改变结果类型使其更加符合初始化规则：

1. 对于引用，编译器以引用对象的类型作为 auto 的类型；
2. 编译器会忽略掉顶层const，同时保留底层const；

**decltype 类型指示符**

当我们希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，可以用 decltype 类型指示符。decltype 和 auto 处理顶层 const 和引用的方式不同：

1. 如果 decltype 使用的表达式是一个变量，则decltype 返回该变量的类型（包括顶层const和引用在内。）
2. 如果 decltype 使用的表达式是一个变量，并且给变量加了一层或者多层括号，编译器会把它当作引用类型。
3. 如果 decltype 使用的表达式不是一个变量，则返回表达式结果对应的类型。
4. 如果表达式内容是解引用操作，则得到引用类型。

## 2.6 自定义数据结构

数据结构是一种把一组相关的数据元素组织起来然后使用它们的策略和方法。C++ 提供了一些常用的数据结构，比如 vector 和 string等，此外还允许我们以类的形式自定义数据结构。关于类的部分[第七章](../chap07/)再做讨论。

